<?php

namespace Dentaku\Redmine\Repository\Issues;

use Carbon\CarbonInterface;
use Dentaku\Redmine\Collection\IdentityCollection;
use Dentaku\Redmine\Model\AbstractModel;
use Dentaku\Redmine\Model\CustomField;
use Dentaku\Redmine\Model\User\Watcher;
use Dentaku\Redmine\Repository\AbstractRepository;
use Dentaku\Redmine\Model\Issue\Attachment;
use Dentaku\Redmine\Model\Issue\Changeset;
use Dentaku\Redmine\Model\Issue\Issue;
use Dentaku\Redmine\Model\Issue\Journal;
use Dentaku\Redmine\Model\Issue\Relation;
use Dentaku\Redmine\Repository\RepositoryInterface;

class Issues extends AbstractRepository
{
    public const API_ROOT = "issues";

    public const ISSUE_RELATION_CHILDREN = "children";
    public const ISSUE_RELATION_ATTACHMENTS = "attachments";
    public const ISSUE_RELATION_RELATIONS = "relations";
    public const ISSUE_RELATION_JOURNALS = "journals";
    public const ISSUE_RELATION_CHANGESETS = "changesets";
    public const ISSUE_RELATION_WATCHERS = "watchers";
    public const ISSUE_RELATION_CUSTOM_FIELDS = "custom_fields";

    public const ISSUE_FILTER_ISSUE_ID = "issue_id";
    public const ISSUE_FILTER_PARENT_ID = "parent_id";
    public const ISSUE_FILTER_PROJECT_ID = "project_id";
    public const ISSUE_FILTER_SUBPROJECT_ID = "subproject_id";
    public const ISSUE_FILTER_TRACKER_ID = "tracker_id";
    public const ISSUE_FILTER_STATUS_ID = "status_id";
    public const ISSUE_FILTER_ASSIGNED_TO_ID = "assigned_to_id";


    protected static array $relation_class_map = [
        self::ISSUE_RELATION_CHILDREN => Issue::class,
        self::ISSUE_RELATION_ATTACHMENTS => Attachment::class,
        self::ISSUE_RELATION_RELATIONS => Relation::class,
        self::ISSUE_RELATION_JOURNALS => Journal::class,
        self::ISSUE_RELATION_CHANGESETS => Changeset::class,
        self::ISSUE_RELATION_WATCHERS => Watcher::class,
        self::ISSUE_RELATION_CUSTOM_FIELDS => CustomField::class
    ];

    protected static array $allowed_filters = [
        self::ISSUE_FILTER_ISSUE_ID => RepositoryInterface::SEARCH_PARAM_TYPE_INT_ARRAY,
        self::ISSUE_FILTER_PROJECT_ID => RepositoryInterface::SEARCH_PARAM_TYPE_INT,
        self::ISSUE_FILTER_SUBPROJECT_ID => RepositoryInterface::SEARCH_PARAM_TYPE_INT,
        self::ISSUE_FILTER_TRACKER_ID => RepositoryInterface::SEARCH_PARAM_TYPE_INT,
        self::ISSUE_FILTER_STATUS_ID => RepositoryInterface::SEARCH_PARAM_TYPE_INT,
        self::ISSUE_FILTER_PARENT_ID => RepositoryInterface::SEARCH_PARAM_TYPE_INT,
        self::ISSUE_FILTER_ASSIGNED_TO_ID => RepositoryInterface::SEARCH_PARAM_TYPE_INT,
        self::COMMON_FILTER_CREATED_ON => CarbonInterface::class,
        self::COMMON_FILTER_UPDATED_ON => CarbonInterface::class,
        self::COMMON_FILTER_CUSTOM_FIELDS => RepositoryInterface::SEARCH_PARAM_TYPE_CF_ARRAY
    ];

    public function getModelClass(): string
    {
        return Issue::class;
    }

    public function get(mixed $id): ?AbstractModel
    {
        $issue = parent::get($id); // TODO: Change the autogenerated stub
        if ($issue) {
            if (in_array(self::ISSUE_RELATION_RELATIONS, $this->fetch_relations, true)) {
                $relations = $this->getRelations($issue);
                if ($relations) {
                    $issue->setRelations($relations);
                }
            }

        }

        return $issue;
    }

    public function create(AbstractModel $model): ?AbstractModel
    {
        /** @var Issue $issue */
        $issue = parent::create($model);
        if ($issue) {
            foreach ($issue->getRelations() as $relation) {
                $this->addRelation($issue, $relation);
            }
        }

        return $issue;
    }

    public function update(AbstractModel $model): ?AbstractModel
    {
        foreach ($model->getRelations() as $relation) {
            if (!$relation->isPersisted()) {
                $this->addRelation($model, $relation);
            }
        }

        return parent::update($model);
    }

    public function getRelations(Issue $issue): IdentityCollection
    {
        $ret = new IdentityCollection();

        $endpoint = $this->getEndpoint() . "/" . $issue->getId() . "/relations" . "." . $this->client->getFormat();
        $response = $this->client->get($endpoint);

        if ($response->isSuccess()) {
            foreach ($response->getData()["relations"] as $relation_data) {
                $relation = (new Relation())->fromArray($relation_data);
                $ret->add($relation);
            }
        }

        return $ret;

    }

    public function addRelation(Issue $issue, Relation $relation): Issue
    {
        $endpoint = $this->getEndpoint() . "/" . $issue->getId() . "/relations" . "." . $this->client->getFormat();
        $response = $this->client->post($endpoint, json_encode($relation->getPayload(), JSON_THROW_ON_ERROR));
        if ($response->isSuccess()) {
            $issue->addRelation($relation);
        }

        return $issue;

    }

}